//
//  GenerateAST.swift
//  Slox (iOS)
//
//  Created by Patrick Van den Bergh on 09/04/2022.
//

import Foundation

var code = ""

print("GenerateAST started...")
if let outputDir = getEnvironmentVar("SCRIPT_OUTPUT_FILE_0") {
    defineAst(outputDir, "Expr", [
        "Binary=_ left: Expr, _ oper: Token, _ right: Expr",
        "Grouping=_ expression: Expr",
        "Literal=_ value: AnyObject?",
        "Unary=_ oper: Token, _ right: Expr"
    ])
} else {
    print("Error: Could not find SCRIPT_OUTPUT_FILE_0")
    exit(-1)
}

func getEnvironmentVar(_ name: String) -> String? {
    guard let rawValue = getenv(name) else { return nil }
    return String(utf8String: rawValue)
}

func defineAst(_ outputDir: String, _ baseName: String, _ types: [String]) {
    let path = outputDir + "/" + baseName + ".swift"
    let fileURL = URL(fileURLWithPath: path)
    code = "//\n"
    code += "//  " + baseName + ".swift\n"
    code += "//  Generated\n"
    code += "//\n"
    code += "//  Generated by GenerateAST.swift\n\n"
    // Visitor protocol
    defineVisitor(baseName, types)
    // Component protocol
    defineComponent(baseName)
    // BaseName protocol
    defineBaseName(baseName)
    // The AST classes
    for type in types {
        let className = String(type.split(separator: "=")[0])
        let fields = String(type.split(separator: "=")[1])
        defineType(baseName, className, fields)
    }
    
    guard let data = code.data(using: .utf8) else {
        print("Error: Unable to convert string to data")
        exit(-1)
    }
    
    do {
        try data.write(to: fileURL)
        print("File saved: \(fileURL.absoluteURL)")
    } catch {
        // Catch any errors
        print(error.localizedDescription)
        exit(-1)
    }
}

func defineType(_ baseName: String, _ className: String, _ fieldList: String) {
    let fields = fieldList.split(separator: ",")
    code += "class " + className + ": " + baseName + " {\n"
    // Fields
    for field in fields {
        let name = field.split(separator: " ")[1].trimmingCharacters(in: CharacterSet(charactersIn: ":"))
        let type = field.split(separator: " ")[2]
        code += "  var " + name + ": " + type + "\n"
    }
    // Constructor
    code += "  init(" + fieldList + ") {\n"
    // Store parameters in fields.
    for field in fields {
        let name = field.split(separator: " ")[1].trimmingCharacters(in: CharacterSet(charactersIn: ":"))
        code += "    self." + name + " = " + name + "\n"
    }
    code += "  }\n"
    // Component protocol
    code += "  typealias T = " + className + "\n"
    code += "\n"
    code += "  override func accept<V>(_ visitor: V) -> V.T where V : " + baseName + "Visitor {\n"
    code += "    return visitor.visit" + className +  baseName + "(self)\n"
    code += "  }\n"
    code += "}\n"
}

func defineVisitor(_ baseName: String, _ types: [String]) {
    // Generate the Visitor protocol
    code += "protocol " + baseName + "Visitor {\n"
    code += "  associatedtype T\n"
    code += "\n"
    code += "  func visit" + baseName + "(_ expr: " + baseName + ") -> T\n"
    for type in types {
        let typeName = type.split(separator: "=")[0]
        code += "  func visit" + typeName + baseName + "(_ expr: " + typeName + ") -> T\n"
    }
    code += "}\n"
    code += "\n"
}

func defineComponent(_ baseName: String) {
    // Generate the Component protocol
    code += "protocol " + baseName + "Component {\n"
    code += "  associatedtype T\n"
    code += "  func accept<V: " + baseName + "Visitor>(_ visitor: V) -> V.T\n"
    code += "}\n"
    code += "\n"
}

func defineBaseName(_ baseName:String) {
    // Generate the Component protocol
    code += "class " + baseName + ": " + baseName + "Component {\n"
    code += "  typealias T = " + baseName + "\n"
    code += "\n"
    code += "  func accept<V>(_ visitor: V) -> V.T where V : " + baseName + "Visitor {\n"
    code += "    return visitor.visit" + baseName + "(self)\n"
    code += "  }\n"
    code += "}\n"
    code += "\n"
}
